normal at, make it use inversed matrix insteda of calculating it 

copy transformation matrices

make light multiple sources


//how to calculate normals:
/*note:: in calculating normal we need to take the point 
and convert it to the object space so that its centered at the origin,
then we can calculate normal normally but its in object space 
and to convert it back to world space 
we need to multiply with transpose of the inversed transformation matrix*/

//t_world commented? nope

check world.c for the the color_at/draw_world

//shade_hit is where to call lighting of all light sources

abs warning?

make sure you're using is equal if youre trying to compare floats

try to understand over point a little more

why work with over_point on lighting instead of just on making the shadow ray





/// transform used in intersect

change set_transform
put the transformation and material in Object
make intersecting going through objects and intersect using its function, (put it as function ptr in its struct)
intersect(ray,object)

normal_at and in intersect it uses transformation of sphere, change it to transformation of object

understand more xoffset and such in calculating the cam

check why do we have to normalize>> u normalize direction so when u get intersection you take it as distance and u can multiply it with that unit vector that is direction to find exactly that point and vice versa

do shadow reflect? should they?// 3 reflective floos + walls+ sphere close to wall so shadow recursive a few times
bug when checkerboard reflected

circle pattern reflection bugged// thats no bug// its supposed to look like its a complete circle
shadow reflecting on shadow will it make it darker in the reflecting surface? (mirror having a shadow on a position and theres shadow from the reflection reflected there, will it be darker)

try rotating the floor withiut bugging it

add multi light